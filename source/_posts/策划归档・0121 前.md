---
title: 策划归档・0121 前・战斗系统
tags:
  - 机制更改
  - 战斗系统
  - 存储系统
  - 原六调整
category: 自家盘灵
date: 2026-01-21 12:01:37
---

最初的，对战斗机制和玩家仓库的构想。
以及，为什么我要写这个服务器。

<!-- more -->

# 世界设置

四个地区改成四个分支，而非四个等级。

怪物给每个玩家独立出来，每个玩家的难度等级不同，怪物强度不同

允许设置各个地区刷给自己的怪的难度等级，高难度掉高阶材料

# 副本更改

镇妖塔正塔的更改：

杀小怪或者完成一些关卡任务出关底 boss，打完对应 boss 进入下一个塔

# 怪物机制

把 Boss 变成三部分：决策 + 行为 + 动作。
其实所有小怪也是这样的，但是决策和行为很单一。

因为怪物大多是独立的，所以每个怪物理应只有 1 个目标，但是副本 Boss 例外，副本 Boss 可以有多个目标。
所以目标会有两个 entry，一个是 `Target mainTarget`，另一个是 `List<Target> allTargets`。
mainTarget 在生物生成时就指定了，allTargets 可能会随怪物的受伤状态实时变更。

## 决策

决策是生物的脑子。
生物需要列举出自身的情况、环境等，通过这些参数来随机出来一个行为。

换句话说，一个决策可以类似于
（注：CONTINUE 表示跳过该逻辑，继续匹配剩下的）

生成后每 tick：
- tickCounter += 1
- handleAllCooldowns()
- if (tickCounter >= 10) { makeSkillDecision() }

```java
public class CustomMob {
    public Target mainTarget;
    public List<Target> allTargets = new ArrayList<>();

    private Behaviour currentBehaviour;
    private float behaviourRemainingTime = 0f;

    private final List<GroupedBehaviour> behaviourGroups = new ArrayList<>();

    private int tickCounter = 0;
    private final Random random = new Random();

    public void tick() {
        tickCounter++;
        handleAllCooldowns();

        if (behaviourRemainingTime > 0) {
            behaviourRemainingTime--;
            return;
        }

        if (tickCounter >= 10) {
            tickCounter = 0;
            makeDecision();
        }
    }

    private void makeDecision() {
        int currentPriority = getPriority(currentBehaviour);

        List<GroupedBehaviour> groups = behaviourGroups.stream()
            .sorted(Comparator.comparingInt(GroupedBehaviour::getPriority).reversed())
            .toList();

      for (GroupedBehaviour group : groups) {
          if (group.getPriority() < currentPriority) continue;

          Behaviour next = group.roll(random);
          if (next == null) continue;

          boolean executed = tryExecute(next);
          if (executed) {
              break;
          }
      }
    }

    private boolean tryExecute(Behaviour next) {
        if (currentBehaviour != null) {
            if (!next.forceInterruptive() && !currentBehaviour.interruptible()) {
                return false;
            }
        }

        forceInterrupt();
        currentBehaviour = next;
        behaviourRemainingTime = next.execute();
        return true;
    }

    private void forceInterrupt() {
        currentBehaviour = null;
        behaviourRemainingTime = 0;
    }

    private int getPriority(Behaviour b) {
        if (b == null) return 0;
        for (GroupedBehaviour g : behaviourGroups) {
            if (g.roll(random) == b) return g.getPriority();
        }
        return 0;
    }
}

public class GroupedBehaviour {
    private final int priority;
    private final Map<Behaviour, Integer> weightedBehaviours;

    private GroupedBehaviour(int priority, Map<Behaviour, Integer> weightedBehaviours) {
        this.priority = priority;
        this.weightedBehaviours = weightedBehaviours;
    }

    public int getPriority() {
        return priority;
    }

    public Behaviour roll(Random random) {
        int totalWeight = 0;

        for (Map.Entry<Behaviour, Integer> e : weightedBehaviours.entrySet()) {
            Behaviour b = e.getKey();
            if (b == null || b.canExecute()) {
                totalWeight += e.getValue();
            }
        }

        if (totalWeight <= 0) {
            return null;
        }

        int r = random.nextInt(totalWeight);
        int acc = 0;

        for (Map.Entry<Behaviour, Integer> e : weightedBehaviours.entrySet()) {
            Behaviour b = e.getKey();
            if (b != null && !b.canExecute()) continue;

            acc += e.getValue();
            if (r < acc) {
                return b;
            }
        }
        return null;
    }
    public static class Builder {
        private final int priority;
        private final Map<Behaviour, Integer> weightedBehaviours = new LinkedHashMap<>();

        public Builder(int priority) {
            this.priority = priority;
        }

        public Builder add(Behaviour behaviour, int weight) {
            weightedBehaviours.put(behaviour, weight);
            return this;
        }

        public BuilderFinal addContinue(int weight) {
            return new BuilderFinal(priority, weightedBehaviours, weight);
        }

        public GroupedBehaviour build() {
            return new GroupedBehaviour(priority, new LinkedHashMap<>(weightedBehaviours));
        }

        public final class BuilderFinal {
            private final int continueWeight;

            private BuilderFinal(int continueWeight) {
                this.continueWeight = continueWeight;
            }

            public GroupedBehaviour build() {
                weightedBehaviours.put(null, continueWeight);
                return new GroupedBehaviour(priority, new LinkedHashMap<>(weightedBehaviours));
            }
        }
    }
}

```

假设这个生物是一个骷髅战士精英怪，冒号后面的是行为和概率，冷却和计数器在怪物实例内内置。

当生物周围 64 格内没有玩家：强制删除
当生物周围 32 格内没有玩家：IDLE-1 25%, IDLE-2 25%, RANDOM_MOVE 50%
当生物周围 32 格内存在玩家，且 Skill3 不在冷却：SKILL_3 40%, CONTINUE 60%
当生物周围 32 格内存在玩家，且 Skill2 不在冷却：SKILL_2
当生物周围 12 格内存在玩家，且技能计数器为 1：SKILL_1_1
当生物周围 4 格内存在玩家，且 Skill1 不在冷却，技能计数器为 0：SKILL_1_0
当生物周围 16 格内存在玩家，且攻击计数器为 3：ATTACK_3
当生物周围 8 格内存在玩家，且攻击计数器为 2：ATTACK_2
当生物周围 4 格内存在玩家，且攻击计数器为 1：ATTACK_1
当生物周围 8 格内存在玩家，且攻击计数器为 0：ATTACK_0 25%, ATTACK_NORMAL 75%
否则（当生物周围 32 格内存在玩家）：WALK_TO_TARGET 75%, RUN_TO_TARGET 25%

## 行为

```java
public abstract class Behaviour {
    protected final CustomMob mob;

    public Behaviour(CustomMob mob) {
        this.mob = mob;
    }

    public abstract boolean canExecute();

    public abstract float execute();

    public boolean forceInterruptive() {
        return false;
    }

    public boolean interruptible() {
        return false;
    }

    public boolean skillInterruptible() {
        return false;
    }
}
```

以上面为例子：

例如说当怪物在 IDLE-1 / IDLE-2 / RANDOM_MOVE 行为时：这个行为的优先级是最低的，索敌的优先级会比 IDLE 更高，强制删除优先级理论上最高。

在 IDLE-1 的持续时间下，怪物不会被 IDLE-2 或 RANDOM_MOVE 打断 IDLE-1 的动作。

## 动作

```java
public interface Action {
    float perform();
}

public class SwingSwordAction implements Action {
    private final SampleMob mob;

    public SwingSwordAction(SampleMob mob) {
        this.mob = mob;
    }

    @Override
    public float perform() {
        mob.getAnimationManager.xxxxxxxxxxxxxxxxxxxx();
        return 0.8f; 
    }
}
```

因为怪物是由体节和碰撞（指展示实体和交互实体）组成的，所以调用 action 的时候要动上面的东西
然后 return 0.8f 这个可能要根据 tps 动态计算，或者到时候改成 return ticks，看情况

# 战斗机制从头来过

新战斗以「动作」和「交互」为主。战弓丹的「职业定位不同」从「数值上的不同」变成「机制上的不同」。

弹反容错（格挡反击的额外判定时间（tick））
弹反冷缩（格挡反击的冷却时间减免倍率）
弹反倍率（格挡反击的额外伤害乘算区间倍率）
- 格挡反击：战士的特有专精技能，可以格挡特定来源的伤害，并对敌方单位造成当次伤害的一定倍率；太刀居合斩；弹反时无法移动无法攻击
- 格挡反击进入冷却时退化为格挡；只可格挡不可反击，消耗体力且不吃任何增幅，格挡失败有僵直；一段时间后恢复

会心等级（会心一击的追加伤害次数）
会心容错（会心一击的额外伤害判定区域（distance））
会心倍率（会心一击的单次追加伤害乘算区间倍率）
- 会心一击：弓箭手的特有专精技能，后撤并进行特殊攻击，可以在特定时机命中敌人薄弱点，并对敌方单位造成大量追加穿甲伤害
- 会心一击失败后退化为翻滚；只后撤不攻击，消耗体力且不吃任何增幅；一段时间后恢复

打断强度（低级 / 中级 / 高级）
打断范围（打断的判定范围）
打断倍率（打断的僵直时间增幅）
- 鼎之震荡：炼丹师的特有专精技能，可以在特定时机打断敌人技能前后摇，并对敌人造成一定物理伤害和一定时间僵直
- 鼎之震荡冷却时退化为格挡；只可格挡不可反击，消耗体力且不吃任何增幅，格挡动作有前摇并减少移速，格挡失败自身僵直

所有的这些东西做成技能。

怪物的「可格挡/可会心/可打断」状态就是读技能（skillInterruptible()）

# 技能系统

技能通过快捷栏释放，一个玩家会有 6 个技能，占用 6 个快捷栏，分别是两个职业特殊技和 6 个大招。

快捷栏：技能1 技能2 技能3 上一个物品 当前物品 下一个物品 技能4 技能5 技能6
玩家无法选中除了槽位 5「当前物品」以外的任何槽位；
切换到 槽位 4 或 槽位 6 会切换当前物品，并使「上一个物品」和「下一个物品」进行相对应的改动。

切换到对应技能槽的时候释放技能

# 存储相关更改

玩家仓库 & 饰品栏 会整合到末影箱中，只能在指定位置存取；皇城中会给一个存取位置

移除所有住宅的箱子，加大住宅获取难度，会开放皇城住宅获取，代价和途径待定

# 遗言

有很多服务器的反作弊杀人特别多，并且误判严重，影响性能严重，所以我想做掉反作弊。
如果给玩家足够的能力，甚至把游戏从依赖原版方法的结算变成基于原版方法的结算，那么绝大多数的反作弊都会在服务器上失效，有能力的写他们自己的辅助也不会有太大问题。

基于计分板的各种功能在性能上有缺陷，并且无法支持玩家改名。
如果使用正版服，做基于玩家 uuid 的存储，那么玩家只要有一个正版账号那么想怎么样就可以怎么样。

想法很不成熟，但是我还是想继续下去。

后会有期。
